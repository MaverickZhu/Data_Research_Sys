# 知识图谱数据库迁移方案
## 2025年8月14日

### 🎯 **迁移目标**
从MongoDB迁移到FalkorDB，实现知识图谱存储和查询性能的根本性提升。

### 📊 **性能目标**
- **当前性能**: 17.5条/秒 (MongoDB)
- **目标性能**: 1000+条/秒 (FalkorDB)
- **预期提升**: 57倍性能提升

### 🏗️ **技术架构对比**

#### MongoDB方案 (当前)
```
原始数据 → 实体抽取 → MongoDB存储 → 复杂查询 → 结果返回
```
**问题**:
- 图查询需要多次JOIN操作
- 缺乏图遍历优化
- 三元组存储格式复杂

#### FalkorDB方案 (目标)
```
原始数据 → 实体抽取 → FalkorDB图存储 → Cypher查询 → 高速返回
```
**优势**:
- 原生图遍历算法
- GraphBLAS矩阵运算
- 内存级查询性能

### 🚀 **实施计划**

#### **第一阶段: 环境搭建 (1天)**

**1.1 FalkorDB Docker部署**
```bash
# 创建数据目录
mkdir -p ./docker/falkordb/data

# 启动FalkorDB (带Web界面)
docker run -d \
  --name knowledge-graph-db \
  -p 6379:6379 \
  -p 3000:3000 \
  -v ./docker/falkordb/data:/var/lib/falkordb/data \
  --restart unless-stopped \
  falkordb/falkordb:edge
```

**1.2 Python客户端安装**
```bash
pip install falkordb-py
```

**1.3 连接测试**
```python
from falkordb import FalkorDB

# 连接FalkorDB
db = FalkorDB(host='localhost', port=6379)
g = db.select_graph('knowledge_graph')

# 测试查询
result = g.query("RETURN 'Hello FalkorDB!'")
print(result.result_set[0][0])
```

#### **第二阶段: 数据模型设计 (1天)**

**2.1 图模型定义**
```cypher
// 实体节点类型
CREATE INDEX FOR (e:Entity) ON (e.id)
CREATE INDEX FOR (e:Entity) ON (e.type)
CREATE INDEX FOR (e:Entity) ON (e.label)

// 组织实体
CREATE (org:Organization {
  id: $entity_id,
  label: $entity_label,
  type: 'ORGANIZATION',
  confidence: $confidence,
  source_table: $source_table,
  properties: $properties
})

// 关系类型
CREATE INDEX FOR ()-[r:SIMILAR_TO]-() ON (r.confidence)
CREATE INDEX FOR ()-[r:LOCATED_IN]-() ON (r.confidence)
CREATE INDEX FOR ()-[r:BELONGS_TO]-() ON (r.confidence)
```

**2.2 数据转换脚本**
```python
class MongoToFalkorDBMigrator:
    def __init__(self):
        self.mongo_client = get_db_manager()
        self.falkor_db = FalkorDB(host='localhost', port=6379)
        self.graph = self.falkor_db.select_graph('knowledge_graph')
    
    def migrate_entities(self):
        """迁移实体数据"""
        entities = self.mongo_client.get_collection('kg_entities')
        batch_size = 1000
        
        for batch in self.batch_iterator(entities.find(), batch_size):
            cypher_queries = []
            for entity in batch:
                query = f"""
                CREATE (e:Entity {{
                    id: '{entity['id']}',
                    label: '{entity['label']}',
                    type: '{entity['type']}',
                    confidence: {entity['confidence']},
                    source_table: '{entity['source_table']}',
                    properties: {json.dumps(entity['properties'])}
                }})
                """
                cypher_queries.append(query)
            
            # 批量执行
            batch_query = ";\n".join(cypher_queries)
            self.graph.query(batch_query)
    
    def migrate_relations(self):
        """迁移关系数据"""
        relations = self.mongo_client.get_collection('kg_relations')
        batch_size = 500
        
        for batch in self.batch_iterator(relations.find(), batch_size):
            cypher_queries = []
            for relation in batch:
                query = f"""
                MATCH (s:Entity {{id: '{relation['subject_id']}'}})
                MATCH (o:Entity {{id: '{relation['object_id']}'}})
                CREATE (s)-[r:{relation['predicate_type']} {{
                    confidence: {relation['confidence']},
                    evidence: {json.dumps(relation.get('evidence', []))},
                    created_time: '{relation['created_time']}'
                }}]->(o)
                """
                cypher_queries.append(query)
            
            batch_query = ";\n".join(cypher_queries)
            self.graph.query(batch_query)
```

#### **第三阶段: 数据迁移执行 (2天)**

**3.1 迁移脚本开发**
```python
# scripts/migrate_to_falkordb.py
import sys
sys.path.append('src')

from database.connection import get_db_manager
from falkordb import FalkorDB
import json
from datetime import datetime

def main():
    print("🚀 开始知识图谱数据迁移...")
    
    migrator = MongoToFalkorDBMigrator()
    
    # 第1步: 迁移实体
    print("📊 迁移实体数据...")
    migrator.migrate_entities()
    
    # 第2步: 迁移关系
    print("🔗 迁移关系数据...")
    migrator.migrate_relations()
    
    # 第3步: 验证数据
    print("✅ 验证迁移结果...")
    migrator.validate_migration()
    
    print("🎉 迁移完成!")

if __name__ == "__main__":
    main()
```

**3.2 执行迁移**
```bash
python scripts/migrate_to_falkordb.py
```

#### **第四阶段: 系统集成 (3天)**

**4.1 数据库连接层重构**
```python
# src/database/falkor_connection.py
from falkordb import FalkorDB
from typing import List, Dict, Any

class FalkorDBManager:
    def __init__(self):
        self.db = FalkorDB(host='localhost', port=6379)
        self.graph = self.db.select_graph('knowledge_graph')
    
    def query_entities(self, entity_type: str = None, limit: int = 100) -> List[Dict]:
        """查询实体"""
        if entity_type:
            query = f"""
            MATCH (e:Entity {{type: '{entity_type}'}})
            RETURN e
            LIMIT {limit}
            """
        else:
            query = f"""
            MATCH (e:Entity)
            RETURN e
            LIMIT {limit}
            """
        
        result = self.graph.query(query)
        return [self._node_to_dict(record[0]) for record in result.result_set]
    
    def query_relations(self, relation_type: str = None, limit: int = 100) -> List[Dict]:
        """查询关系"""
        if relation_type:
            query = f"""
            MATCH (s:Entity)-[r:{relation_type}]->(o:Entity)
            RETURN s, r, o
            LIMIT {limit}
            """
        else:
            query = f"""
            MATCH (s:Entity)-[r]->(o:Entity)
            RETURN s, r, o
            LIMIT {limit}
            """
        
        result = self.graph.query(query)
        return [self._relation_to_dict(record[0], record[1], record[2]) 
                for record in result.result_set]
    
    def search_similar_entities(self, entity_id: str, min_confidence: float = 0.8) -> List[Dict]:
        """搜索相似实体"""
        query = f"""
        MATCH (e1:Entity {{id: '{entity_id}'}})-[r:SIMILAR_TO]-(e2:Entity)
        WHERE r.confidence >= {min_confidence}
        RETURN e2, r.confidence
        ORDER BY r.confidence DESC
        """
        
        result = self.graph.query(query)
        return [{'entity': self._node_to_dict(record[0]), 'confidence': record[1]} 
                for record in result.result_set]
```

**4.2 API层适配**
```python
# src/web/app.py 中的修改
from database.falkor_connection import FalkorDBManager

# 替换原有的MongoDB连接
falkor_db = FalkorDBManager()

@app.route('/api/kg/entities', methods=['GET'])
def get_kg_entities():
    """获取知识图谱实体"""
    try:
        entity_type = request.args.get('type')
        limit = int(request.args.get('limit', 100))
        offset = int(request.args.get('offset', 0))
        
        entities = falkor_db.query_entities(entity_type=entity_type, limit=limit)
        
        return jsonify({
            'entities': entities,
            'total': len(entities),
            'limit': limit,
            'offset': offset,
            'status': 'success'
        })
    except Exception as e:
        logger.error(f"查询实体失败: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/kg/relations', methods=['GET'])
def get_kg_relations():
    """获取知识图谱关系"""
    try:
        relation_type = request.args.get('type')
        limit = int(request.args.get('limit', 100))
        
        relations = falkor_db.query_relations(relation_type=relation_type, limit=limit)
        
        return jsonify({
            'relations': relations,
            'total': len(relations),
            'limit': limit,
            'status': 'success'
        })
    except Exception as e:
        logger.error(f"查询关系失败: {str(e)}")
        return jsonify({'error': str(e)}), 500
```

#### **第五阶段: 性能测试与优化 (2天)**

**5.1 性能测试脚本**
```python
# scripts/performance_test_falkordb.py
import time
from database.falkor_connection import FalkorDBManager

def test_query_performance():
    """测试查询性能"""
    db = FalkorDBManager()
    
    # 测试1: 实体查询
    start_time = time.time()
    entities = db.query_entities(limit=10000)
    entity_time = time.time() - start_time
    print(f"实体查询 (10000条): {entity_time:.2f}秒, {len(entities)/entity_time:.2f} 条/秒")
    
    # 测试2: 关系查询
    start_time = time.time()
    relations = db.query_relations(limit=10000)
    relation_time = time.time() - start_time
    print(f"关系查询 (10000条): {relation_time:.2f}秒, {len(relations)/relation_time:.2f} 条/秒")
    
    # 测试3: 相似性搜索
    if entities:
        start_time = time.time()
        similar = db.search_similar_entities(entities[0]['id'])
        similar_time = time.time() - start_time
        print(f"相似性搜索: {similar_time:.2f}秒")

if __name__ == "__main__":
    test_query_performance()
```

**5.2 性能优化配置**
```bash
# FalkorDB配置优化
docker run -d \
  --name knowledge-graph-db \
  -p 6379:6379 \
  -p 3000:3000 \
  -v ./docker/falkordb/data:/var/lib/falkordb/data \
  --memory=4g \
  --cpus=2 \
  --restart unless-stopped \
  falkordb/falkordb:edge \
  --maxmemory 3gb \
  --maxmemory-policy allkeys-lru
```

### 🎯 **预期收益**

#### **性能提升**
- **查询速度**: 从17.5条/秒 → 1000+条/秒 (57倍提升)
- **响应时间**: 从秒级 → 毫秒级
- **并发能力**: 显著提升

#### **功能增强**
- **图遍历**: 原生支持复杂图查询
- **路径分析**: 多跳关系查询
- **相似性搜索**: 基于图结构的智能推荐
- **实时分析**: 支持实时图分析

#### **运维优势**
- **部署简单**: Docker一键部署
- **监控完善**: Redis生态工具支持
- **备份恢复**: 标准Redis备份方案

### 🔧 **风险控制**

#### **回滚方案**
1. 保留原MongoDB数据作为备份
2. 双写机制确保数据一致性
3. 分阶段切换，降低风险

#### **测试策略**
1. 功能测试: 确保所有API正常工作
2. 性能测试: 验证性能提升目标
3. 压力测试: 确保系统稳定性
4. 数据一致性测试: 验证迁移准确性

### 📅 **实施时间表**

| 阶段 | 任务 | 预计时间 | 负责人 |
|------|------|----------|--------|
| 第1阶段 | 环境搭建 | 1天 | 开发团队 |
| 第2阶段 | 数据模型设计 | 1天 | 架构师 |
| 第3阶段 | 数据迁移 | 2天 | 开发团队 |
| 第4阶段 | 系统集成 | 3天 | 开发团队 |
| 第5阶段 | 测试优化 | 2天 | 测试团队 |
| **总计** | **完整迁移** | **9天** | **全团队** |

### 🎉 **结论**

FalkorDB作为专为GraphRAG和知识图谱优化的数据库，将为您的智能关联匹配系统带来革命性的性能提升。通过这个迁移方案，您将获得:

1. **57倍性能提升** - 从17.5条/秒到1000+条/秒
2. **原生图查询能力** - 复杂关系查询毫秒级响应
3. **简化的架构** - 消除复杂的三元组存储问题
4. **更好的扩展性** - 为未来的GraphRAG功能打下坚实基础

这个方案不仅解决了当前的性能瓶颈，更为您的系统向智能知识平台的演进奠定了技术基础。
